# -*- coding: utf-8 -*-
"""Prediction of objects.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10mx5DQ89t-Q6xjJi0Kst8o59-n9hXgzI
"""

import cv2
from google.colab.patches import cv2_imshow
# Normal images
enh_image = cv2.imread('wolf.jpg')
#cv2_imshow(image)
enh_image = cv2.resize(enh_image, (640, 480))
cv2_imshow(enh_image)
h = enh_image.shape[0]
w = enh_image.shape[1]

# path to the weights and model files
weights = "frozen_inference_graph.pb"
model = "ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt"
# load the MobileNet SSD model trained  on the dataset
net = cv2.dnn.readNetFromTensorflow(weights, model)

# create a blob from the image
blob = cv2.dnn.blobFromImage(
    enh_image, 1.0/127.5, (320, 320), [127.5, 127.5, 127.5])
# pass the blog through network and get the output predictions
net.setInput(blob)
output = net.forward()  # shape: (1, 1, 100, 7)

#Object prediction using SSD
from google.colab.patches import cv2_imshow
# loop over the number of detected objects
for detection in output[0, 0, :, :]:  # output[0, 0, :, :] has a shape of: (100, 7)
    # the confidence of the model regarding the detected object
    probability = detection[2]

    # if the confidence of the model is lower than 50%,
    # we do nothing (continue looping)
    if probability < 0.5:
        continue

    # perform element-wise multiplication to get
    # the (x, y) coordinates of the bounding box
    box = [int(a * b) for a, b in zip(detection[3:7], [w, h, w, h])]
    box = tuple(box)
    # draw the bounding box of the object
    cv2.rectangle(enh_image, box[:2], box[2:], (0, 255, 0), thickness=2)
    label = f"{probability*1 :.2f}"

    cv2.putText(enh_image, label, (box[0], box[1] + 15),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

cv2_imshow(enh_image)

import cv2
from google.colab.patches import cv2_imshow
# Drone images
enh_image = cv2.imread('lion_out.jpg')
#cv2_imshow(image)
enh_image = cv2.resize(enh_image, (640, 480))
cv2_imshow(enh_image)
h = enh_image.shape[0]
w = enh_image.shape[1]

# path to the weights and model files
weights = "frozen_inference_graph.pb"
model = "ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt"
# load the MobileNet SSD model trained  on the COCO dataset
net = cv2.dnn.readNetFromTensorflow(weights, model)

# create a blob from the image
blob = cv2.dnn.blobFromImage(
    enh_image, 1.0/127.5, (320, 320), [127.5, 127.5, 127.5])
# pass the blog through network and get the output predictions
net.setInput(blob)
output = net.forward()  # shape: (1, 1, 100, 7)

#Object prediction in enhanced drone image using SSD
from google.colab.patches import cv2_imshow
# loop over the number of detected objects
for detection in output[0, 0, :, :]:  # output[0, 0, :, :] has a shape of: (100, 7)
    # the confidence of the model regarding the detected object
    probability = detection[2]

    # if the confidence of the model is lower than 50%,
    # we do nothing (continue looping)
    if probability < 0.5:
        continue

    # perform element-wise multiplication to get
    # the (x, y) coordinates of the bounding box
    box = [int(a * b) for a, b in zip(detection[3:7], [w, h, w, h])]
    box = tuple(box)
    # draw the bounding box of the object
    cv2.rectangle(enh_image, box[:2], box[2:], (0, 255, 0), thickness=2)
    label = f"{probability*1 :.2f}"

    cv2.putText(enh_image, label, (box[0], box[1] + 15),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

cv2_imshow(enh_image)

import numpy as np
import matplotlib.pyplot as plt

# Bar chart of SSD Vs YOLOv5 for normal image dataset

data = {'YOLOv5':0.61, 'SSD':0.82}
dataset = list(data.keys())
values = list(data.values())
  
fig = plt.figure(figsize = (5, 4))
 
# creating the bar plot
plt.bar(dataset, values, color ='maroon',
        width = 0.4)
 
plt.xlabel("Models")
plt.ylabel("Accuracy")
plt.title("Models Vs Accuracy for Normal image dataset")
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Bar chart of SSD Vs YOLOv5 for drone image dataset

data = {'YOLOv5':0.68, 'SSD':0.79}
dataset = list(data.keys())
values = list(data.values())
  
fig = plt.figure(figsize = (5, 4))
 
# creating the bar plot
plt.bar(dataset, values, color ='blue',
        width = 0.4)
 
plt.xlabel("Models")
plt.ylabel("Accuracy")
plt.title("Models Vs Accuracy for Drone image dataset")
plt.show()